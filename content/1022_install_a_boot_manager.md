Title: 102.2 Install a boot manager
Date: 2010-12-03 10:20
Category: LPIC1
Tags: LPIC1, 101, LPIC1-101-500
Authors: Jadi
Summary: Candidates should be able to select, install and configure a boot manager.
sortorder: 070

_Weight: 2_ 

Description: Candidates should be able to select, install and configure a boot manager.

## Objectives

* Providing alternative boot locations and backup boot options.
* Install and configure a boot loader such as GRUB Legacy.
* Perform basic configuration changes for GRUB 2.
* Interact with the boot loader

## Terms and Utilities

* `menu.lst`, `grub.cfg` and `grub.conf`
* grub-install
* grub-mkconfig
* MBR

## Boot overview

<iframe width="560" height="315" src="https://www.youtube.com/embed/G_FzcMZYDbg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Most systems use BIOS or UEFI. When on BIOS, the system will do a self test called POST (Power-On Self-Test). Then it will hand over the boot process to the first sector of Master Boot Record \(MBR\) which is track \(Cylinder\) 0, side \(Head\) 0 and Sector 1 of the first disk. 

MBR is only 512 bytes so we need a _smart bootloader_ to handle larger boot managers and even multiple systems. Some of these boot loaders are LILO, GRUB and GRUB2.

If the system is using UEFI, the hardware will follow the UEFI stages. They start with a security phase and will continue till the end phase where the UEFI looks for an EFI System Partition, which is just a FAT32 partition (Usually the first one, but that's implementation-defined) with PE executables and runs them. 

In both cases, the binary starts the boot loader. It might be a complete bootloader on `/boot/efi/` of your computer or a small loader for the main grub on the MBR or a windows loader or even a chainloader.

> Chain Loading is when a boot loader, loads another boot loader. This is done when a Linux bootloader needs to start a Windows system.

## GRUB


**GRUB** \(**GR**and **U**nified **B**ootloader\) started to replace the older LILO. The first version (1) is called Grub Legacy and started in 1999. The 2nd version started in 2005 and is a complete rewrite of version 1.

It's a menu-based system where you can choose which Kernel or chainloader to boot. It is also possible to edit the menus on the fly or give direct commands from a command line.

### Grub Legacy

Usually the GRUB v1 \(actually 0.9\) is installed in `/boot/grub`. Its main configuration is in `/boot/grub/menu.lst` but nowadays some distros (including RedHat Based ones) link this to the `/boot/grub/grub.conf`.

A sample `menu.lst` / `grub.conf` file for GRUB legacy consists of two sections. The first section contains global configs and the 2nd part defines different kernel/initram or chainloader options.

The global configs are:

|Config|Description|
|:------|:-----------|
| \# | Comment |
|color|Foreground and background colors for normal and active items|
|default|Which boot menu item is the default|
|fallback|Which boot menu should be used if the _default_ fails|
|hiddenmenu|Hide the menu options|
|splashimage|Show this image in the background!|
|timeout|Wait this much and then start the default|
| password | Security is important! Will ask this password |
| savedefault | Remember the last booted item |


On the second part of the config, we have these:

|Config|Description|
|:------|:-----------|
|title|Defines the section name|
|root|Disk and partition where `/boot` directory is. In the form of (hddrive, partition), say (hd0, 0) or (hd0, msdos0)|
|kernel|Kernel image file name in `/boot`|
|initrd|Initramfs file in `/boot`|
|rootnoverify|Defines a non-Linux root partition|
| chainloader | Another file will act as stage 1 loader. Used for booting Windows systems |

Here you can see a sample of GRUB-Legacy config:

```text
# grub.conf generated by anaconda
#
# Note that you do not have to rerun grub after making changes to this file
# NOTICE:  You do not have a /boot partition.  This means that
#          all kernel and initrd paths are relative to /, eg.
#          root (hd0,5)
#          kernel /boot/vmlinuz-version ro root=/dev/sda6
#          initrd /boot/initrd-version.img
#boot=/dev/sda6
default=1
timeout=10
splashimage=(hd0,5)/boot/grub/splash.xpm.gz
#hiddenmenu
password --md5 $1$RW1VW/$4XGAklxB7/GJk0uO47Srx1
title Upgrade to Fedora 11 (Leonidas)
    kernel /boot/upgrade/vmlinuz preupgrade \
      repo=hd::/var/cache/yum/preupgrade stage2=\
      hd:UUID=8b4c62e7-2022-4288-8995-5eda92cd149b:/boot/upgrade/install.img \
      ks=hd:UUID=8b4c62e7-2022-4288-8995-5eda92cd149b:/boot/upgrade/ks.cfg
    initrd /boot/upgrade/initrd.img
title Fedora (2.6.26.8-57.fc8)
    root (hd0,5)
    kernel /boot/vmlinuz-2.6.26.8-57.fc8 ro root=LABEL=FEDORA8 rhgb quiet
    initrd /boot/initrd-2.6.26.8-57.fc8.img
title Fedora (2.6.26.6-49.fc8)
    root (hd0,5)
    kernel /boot/vmlinuz-2.6.26.6-49.fc8 ro root=LABEL=FEDORA8 rhgb quiet
    initrd /boot/initrd-2.6.26.6-49.fc8.img
title GRUB Menu
    rootnoverify (hd0,1)
    chainloader +1
title Windows
    rootnoverify (hd0,0)
    chainloader +1
```


#### GRUB \(legacy\) commands

After creating the configuration, you need to install the grub on a disk MBR. To do this you can use two different formats:

```text
# grub-install /dev/fd0
# grub-install '(fd0)'
```


Just like any other boot manager, you can install grub on a CD, floppy, MBR \(`/dev/sda`, `/dev/sdb`, ..\) or a partition \(`/dev/sdb2`, `/dev/sda6`, ..\). But if you want to install it on anywhere other than the MBR, use a chainloader to point your boot sequence toward it.


If you needed to change or reconfigure anything during the startup, just press the `e` on that item and you'll get an interactive editing environment. Press **Enter** when done and `b` for boot.

#### Interacting with GRUB Legacy
If you press `c` on the grub menu, you will go into the _GRUB Command Line_ or _GRUB shell_. There you can type commands like `root` and `kernel` and `initrd` and boot the system with `boot` or press the `Esc` key to return back to the menu. 

### GRUB2

<iframe width="560" height="315" src="https://www.youtube.com/embed/lB-1orohGA0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

This is the most common boot loader these days. On BIOS systems it is installed on `/boot/grub/` or `/boot/grub2/` and under UEFI it goes in `/boot/efi/EFI/distro-name/` (say `/boot/efi/EFI/fedora/`). GRUB2's configuration file is called `grub.cfg`.

Here is a simplified `grub.cfg`:

```
set default="0"
menuentry "Fedora" { 
  set root=(hd0,1)
  linux /boot/vmlinuz-5.10.0-9-arm64 ro quiet
  initrd /boot/initrd.img-5.10.0-9-arm64
}
menuentry "Windows" {
  chainloader (hd1,msdos2)+1
}
```

As you can see, GRUB uses Linux-style numbering for partitions, so the first partition on the first hard disk is `(hd0,1)` or `(hd0,msdos1)` for DOS partitions or `(hd0,gpt1)` for GPT drives.

Here you can see some of the options:

|Option|Description|
|:----|:----|
|menuentry|Defines a new menuentry|
|set root|Defines the root where `/boot` located|
|linux, linux16|Defines the location of the Linux kernel on BIOS systems|
|linuxefi|Defines the Linux kernel on UEFI systems|
|initrd|Defines the initramfs image for BIOS systems|
|initrdefi|Defines the initramfs image for UEFI systems|

And here is a real-world `grub.cfg`:

```
#
# DO NOT EDIT THIS FILE
#
# It is automatically generated by grub-mkconfig using templates
# from /etc/grub.d and settings from /etc/default/grub
#

### BEGIN /etc/grub.d/00_header ###
if [ -s $prefix/grubenv ]; then
  set have_grubenv=true
  load_env
fi
if [ "${next_entry}" ] ; then
   set default="${next_entry}"
   set next_entry=
   save_env next_entry
   set boot_once=true
else
   set default="0"
fi

if [ x"${feature_menuentry_id}" = xy ]; then
  menuentry_id_option="--id"
else
  menuentry_id_option=""
fi

export menuentry_id_option

if [ "${prev_saved_entry}" ]; then
  set saved_entry="${prev_saved_entry}"
  save_env saved_entry
  set prev_saved_entry=
  save_env prev_saved_entry
  set boot_once=true
fi

function savedefault {
  if [ -z "${boot_once}" ]; then
    saved_entry="${chosen}"
    save_env saved_entry
  fi
}
function load_video {
  if [ x$feature_all_video_module = xy ]; then
    insmod all_video
  else
    insmod efi_gop
    insmod efi_uga
    insmod ieee1275_fb
    insmod vbe
    insmod vga
    insmod video_bochs
    insmod video_cirrus
  fi
}

if [ x$feature_default_font_path = xy ] ; then
   font=unicode
else
insmod part_gpt
insmod ext2
if [ x$feature_platform_search_hint = xy ]; then
  search --no-floppy --fs-uuid --set=root  df2d9e14-f1e9-4b1b-95d4-0167caa2461e
else
  search --no-floppy --fs-uuid --set=root df2d9e14-f1e9-4b1b-95d4-0167caa2461e
fi
    font="/usr/share/grub/unicode.pf2"
fi

if loadfont $font ; then
  set gfxmode=auto
  load_video
  insmod gfxterm
  set locale_dir=$prefix/locale
  set lang=en_US
  insmod gettext
fi
terminal_output gfxterm
if [ "${recordfail}" = 1 ] ; then
  set timeout=30
else
  if [ x$feature_timeout_style = xy ] ; then
    set timeout_style=menu
    set timeout=5
  # Fallback normal timeout code in case the timeout_style feature is
  # unavailable.
  else
    set timeout=5
  fi
fi
### END /etc/grub.d/00_header ###

### BEGIN /etc/grub.d/05_debian_theme ###
insmod part_gpt
insmod ext2
if [ x$feature_platform_search_hint = xy ]; then
  search --no-floppy --fs-uuid --set=root  df2d9e14-f1e9-4b1b-95d4-0167caa2461e
else
  search --no-floppy --fs-uuid --set=root df2d9e14-f1e9-4b1b-95d4-0167caa2461e
fi
insmod png
if background_image /usr/share/desktop-base/homeworld-theme/grub/grub-4x3.png; then
  set color_normal=white/black
  set color_highlight=black/white
else
  set menu_color_normal=cyan/blue
  set menu_color_highlight=white/blue
fi
### END /etc/grub.d/05_debian_theme ###

### BEGIN /etc/grub.d/10_linux ###
function gfxmode {
	set gfxpayload="${1}"
}
set linux_gfx_mode=
export linux_gfx_mode
menuentry 'Debian GNU/Linux' --class debian --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-simple-df2d9e14-f1e9-4b1b-95d4-0167caa2461e' {
	load_video
	insmod gzio
	if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi
	insmod part_gpt
	insmod ext2
	if [ x$feature_platform_search_hint = xy ]; then
	  search --no-floppy --fs-uuid --set=root  df2d9e14-f1e9-4b1b-95d4-0167caa2461e
	else
	  search --no-floppy --fs-uuid --set=root df2d9e14-f1e9-4b1b-95d4-0167caa2461e
	fi
	echo	'Loading Linux 5.10.0-9-arm64 ...'
	linux	/boot/vmlinuz-5.10.0-9-arm64 root=UUID=df2d9e14-f1e9-4b1b-95d4-0167caa2461e ro  quiet
	echo	'Loading initial ramdisk ...'
	initrd	/boot/initrd.img-5.10.0-9-arm64
}
submenu 'Advanced options for Debian GNU/Linux' $menuentry_id_option 'gnulinux-advanced-df2d9e14-f1e9-4b1b-95d4-0167caa2461e' {
	menuentry 'Debian GNU/Linux, with Linux 5.10.0-9-arm64' --class debian --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-5.10.0-9-arm64-advanced-df2d9e14-f1e9-4b1b-95d4-0167caa2461e' {
		load_video
		insmod gzio
		if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi
		insmod part_gpt
		insmod ext2
		if [ x$feature_platform_search_hint = xy ]; then
		  search --no-floppy --fs-uuid --set=root  df2d9e14-f1e9-4b1b-95d4-0167caa2461e
		else
		  search --no-floppy --fs-uuid --set=root df2d9e14-f1e9-4b1b-95d4-0167caa2461e
		fi
		echo	'Loading Linux 5.10.0-9-arm64 ...'
		linux	/boot/vmlinuz-5.10.0-9-arm64 root=(hd0,1) ro  quiet
		echo	'Loading initial ramdisk ...'
		initrd	/boot/initrd.img-5.10.0-9-arm64
	}
	menuentry 'Debian GNU/Linux, with Linux 5.10.0-8-arm64 (recovery mode)' --class debian --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-5.10.0-8-arm64-recovery-df2d9e14-f1e9-4b1b-95d4-0167caa2461e' {
		load_video
		insmod gzio
		if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi
		insmod part_gpt
		insmod ext2
		if [ x$feature_platform_search_hint = xy ]; then
		  search --no-floppy --fs-uuid --set=root  df2d9e14-f1e9-4b1b-95d4-0167caa2461e
		else
		  search --no-floppy --fs-uuid --set=root df2d9e14-f1e9-4b1b-95d4-0167caa2461e
		fi
		echo	'Loading Linux 5.10.0-8-arm64 ...'
		linux	/boot/vmlinuz-5.10.0-8-arm64 root=UUID=df2d9e14-f1e9-4b1b-95d4-0167caa2461e ro single 
		echo	'Loading initial ramdisk ...'
		initrd	/boot/initrd.img-5.10.0-8-arm64
	}
}

### END /etc/grub.d/10_linux ###

### BEGIN /etc/grub.d/20_linux_xen ###

### END /etc/grub.d/20_linux_xen ###

### BEGIN /etc/grub.d/30_os-prober ###
### END /etc/grub.d/30_os-prober ###

### BEGIN /etc/grub.d/30_uefi-firmware ###
menuentry 'System setup' $menuentry_id_option 'uefi-firmware' {
	fwsetup
}
### END /etc/grub.d/30_uefi-firmware ###

### BEGIN /etc/grub.d/40_custom ###
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the 'exec tail' line above.
### END /etc/grub.d/40_custom ###

### BEGIN /etc/grub.d/41_custom ###
if [ -f  ${config_directory}/custom.cfg ]; then
  source ${config_directory}/custom.cfg
elif [ -z "${config_directory}" -a -f  $prefix/custom.cfg ]; then
  source $prefix/custom.cfg;
fi
### END /etc/grub.d/41_custom ###

```


#### GRUB2 commands
The installation is done with `grub-install /dev/sda` and after changing the config files, you need to issue  `grub2-mkconfig` or `grub-mkconfig`. It reads the configuration files from `/etc/grub.d/` and `/etc/default/grub/` and create the `grub.cfg` file based on them. You run it like this:

```
grub2-mkconfig > /boot/grub2/grub.cfg
``` 

or 

```
grub2-mkconfig -o /boot/grub2/grub.cfg
``` 


There is also a command called `update-grub` as a frontend to `grub-mkconfig` which runs `grub-mkconfig -o /boot/grub/grub.cfg`

> Please note that on some modern distros, you have both `grub` and `grub2` commands available for compatibility reasons, and one links to the other.


#### Interacting with GRUB2

If you press `c` on the grub menu, you will go into the _GRUB Command Line_ or _GRUB shell_. There you can type commands like `root` and `kernel` and `initrd` and boot the system with `boot` or press the `Esc` key to return back to the menu. 


### Kernel boot parameters
In the above configs, we sent some parameters to the kernel like this:

```
        linux   /boot/vmlinuz-5.10.0-9-arm64 root=/dev/sda1 ro  quiet
```

This tells the kernel to boot in _ReadOnly_ mode and does not show lots of logs during the boot (_quiet_).

These are some of the other options you may use:

|Option|Description|
|:---|:---|
|console=|Set the console|
|debug|Start in debug mode|
|init=|Run an specific program instead of the default init|
|initrd=|Use this initrd|
|ro|Mount the root filesystem read only|
|rw|Mount the root filesystem for read and write|
|root=|Use this as the root filesystem|
|selinux|Disable `selinux` on boot|
|single,S,1,Single|Boot in single user mode for troubleshooting (SysV)|
|systemd.unit=|Boot in this systemd target|
